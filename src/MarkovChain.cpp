/*
 * TextAnalyzer.cpp
 *
 *  Created on: Mar 7, 2020
 *      Author: sam
 *
 *  Description: MarkovChain maps pairs of strings and vectors
 *  of strings to represent pairs of prefixes and a list of suffixes.
 *  Tweets are generated by randomly picking a starting prefix, then
 *  randomly picking a suffix from the list, making the chosen suffix
 *  the new prefix, and repeating.
 */
#include "MarkovChain.hpp"

/* constructor
 * no-arg
 * initializes all fields
 */
MarkovChain::MarkovChain() {
	key_stream = new fstream();
	value_stream = new fstream();
	markov_map = new map<string, vector<string>>();
	key_vec = new vector<string>();
}

/* destructor
 * deletes only the map and list of keys because
 * the fstreams should be closed and deleted
 * immediately after use
 */
MarkovChain::~MarkovChain() {
	delete markov_map;
	delete key_vec;
}

/* parseText
 * input: file path
 * output: void
 * creates the markov chain map
 * note1: will exit program in this method if the source text file
 * is less than 3 words long
 */
void MarkovChain::parseText(string file) {
	key_stream->open(file);
	value_stream->open(file);
	if (!*key_stream || !*value_stream) {
		cout << "failed to open file: " << file << endl;
		key_stream->close();
		value_stream->close();
		delete key_stream;
		delete value_stream;
		delete markov_map;
		delete key_vec;
		exit(1);
	}

	if (key_stream->peek() == EOF) {
		cout << "file is empty" << endl;
		key_stream->close();
		value_stream->close();
		delete key_stream;
		delete value_stream;
		delete markov_map;
		delete key_vec;
		exit(2);
	}

	string key;
	*key_stream >> key;
	string value;
	*value_stream >> value;

	while (*value_stream >> value) {
		(*markov_map)[key].push_back(value);
		*key_stream >> key;
		key_vec->push_back(key);
	}

	if (key_vec->size() <= 1) {
		cout << "file must be at least 3 words long" << endl;
		key_stream->close();
		value_stream->close();
		delete key_stream;
		delete value_stream;
		delete markov_map;
		delete key_vec;
		exit(3);
	}

	key_vec->pop_back();

	key_stream->close();
	value_stream->close();
	delete key_stream;
	delete value_stream;
}

/* generateTweet
 * input: none
 * output: tweet
 * walks through the markov chain and generates tweet
 */
string MarkovChain::generateTweet() {
	string tweet = "";
	string value = "";
	string key = (*key_vec)[rand() % key_vec->size()];
	int character_count = 0;
	bool loop_flag = true;

	while (loop_flag) {
		character_count = tweet.length();
		if (markov_map->find(key) != markov_map->end()) {
			value = (*markov_map)[key][rand() % (*markov_map)[key].size()];
		} else {
			break;
		}
		if (character_count + value.length() < 280) {
			tweet = tweet + " " + key;
		} else {
			loop_flag = false;
		}
		key = value;
	}

	cout << tweet << endl;
	return tweet;
}

/* printMap
 * input: none
 * output: void
 * prints contents of map; used for testing
 */
void MarkovChain::printMap() {
	for (auto const& pair: *markov_map) {
		cout << "{" << pair.first << ": ";
		for (int i = 0; i < pair.second.size(); i ++) {
			cout << pair.second[i] << ", ";
		}
		cout << "}" << endl;
	}
}



